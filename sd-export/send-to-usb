#!/usr/bin/env python3

import datetime
import json
import os
import subprocess
import sys
import tarfile
import tempfile

DEVICE = "/dev/sda1"
MOUNTPOINT = "/media/usb"
ENCRYPTED_DEVICE = "encrypted_volume"
FILE = sys.argv[1]
folder_name = ""
encryption_method = ""
encryption_key = ""
target_folder = "sd-export-{}".format(datetime.datetime.now().strftime("%Y%m%d-%H%M%S"))

tmpdir = tempfile.mkdtemp()

if os.path.exists(FILE):
    try:
        try:
            with tarfile.open(FILE) as tar:
                tar.extractall(tmpdir)
        except Exception as e:
            # exit with 0 return code otherwise the os will attempt to open
            # the file with another application
            sys.stderr.write("Error opening export bundle:")
            sys.stderr.write(e.output)
            sys.exit(0)

        try:
            folder_name = os.path.basename(FILE).split(".")[0]
            with open(os.path.join(tmpdir, folder_name, "metadata.json")) as json_data:
                data = json.load(json_data)
                encryption_method = data["encryption-method"]
                encryption_key = data["encryption-key"]
        except Exception as e:
            sys.stderr.write("Error parsing metadata.")
            sys.stderr.write(e.output)
            sys.exit(0)

        # we only support luks for now
        if encryption_method != "luks":
            sys.stderr.write("Unsupported export encryption.")
            sys.exit(0)

        # the luks device is not already unlocked
        if not os.path.exists(os.path.join("/dev/mapper/", ENCRYPTED_DEVICE)):
            p = subprocess.Popen(
                ["sudo", "cryptsetup", "luksOpen", DEVICE, ENCRYPTED_DEVICE],
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
            )
            stdout_data = p.communicate(input=str.encode(encryption_key, "utf-8"))[0]
            rc = p.returncode
            if rc != 0:
                sys.stderr.write("Bad passphrase or luks error.")
                sys.exit(0)

        # mount target not created
        if not os.path.exists(MOUNTPOINT):
            subprocess.check_call(["sudo", "mkdir", MOUNTPOINT])
        try:
            subprocess.check_call(
                [
                    "sudo",
                    "mount",
                    os.path.join("/dev/mapper/", ENCRYPTED_DEVICE),
                    MOUNTPOINT
                ]
            )
            subprocess.check_call(["sudo", "chown", "-R", "user:user", MOUNTPOINT])
        except subprocess.CalledProcessError as e:
            # clean up
            subprocess.check_call(["sudo", "cryptsetup", "luksClose", ENCRYPTED_DEVICE])
            subprocess.check_call(["rm", "-rf", tmpdir])
            sys.stderr.write("An error occurred while mounting disk :")
            sys.stderr.write(e.output)
            sys.exit(0)

        # move files to drive (overrites files with same filename) and unmount drive
        try:
            target_folder_path = os.path.join(MOUNTPOINT, target_folder)
            subprocess.check_call(["mkdir", target_folder_path])
            export_data = os.path.join(tmpdir, folder_name, "export_data/")
            subprocess.check_call(["cp", "-r", export_data, target_folder_path])
        except (subprocess.CalledProcessError, OSError) as e:
            sys.stderr.write("Error writing to disk:")
            sys.stderr.write(e.output)
            sys.exit(0)
        finally:
            # Finally, we sync the filesystem, unmount the drive and lock the
            # luks volume, and exit 0
            subprocess.check_call(["sync"])
            subprocess.check_call(["sudo", "umount", MOUNTPOINT])
            subprocess.check_call(["sudo", "cryptsetup", "luksClose", ENCRYPTED_DEVICE])
            subprocess.check_call(["rm", "-rf", tmpdir])
            sys.exit(0)

    except Exception as e:
        # exit with 0 return code otherwise the os will attempt to open
        # the file with another application
        sys.stderr.write("Unhandled exception:")
        sys.stderr.write(e.output)
        sys.exit(0)

else:
    sys.stderr.write("File does not exist")
    sys.exit(0)
